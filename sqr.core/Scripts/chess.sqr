module ChessGame;

qlass PieceType {
	String name;
	Qollection symbols;
	Qallable isLegalCallback; 
	Number value;

	fq PieceType(name, symbols, value, isLegalCallback {
		this:name <~ name;
		this:symbols <~ symbols;
		this:value <~ value;
		this:isLegalCallback <~ isLegalCallback;
		return this;
	});

	fq isLegal(board, pos, isAttack {
		<: this:isLegalCallback(board, pos, isAttack);
	});
};

qlass Pos {
	Number x;
	Number y;

	fq Pos(x, y {
		this:x <~ x;
		this:y <~ y;
	});

	fq delta(pos { 
		<: new Pos(this:x - pos:x, this:y - pos:y);
	});
};

qlass Piece {
	PieceType type;
	Pos pos;
	String owner;
};

export qlass Chess {
	fq definePieceTypes({
		*~ r <~ [];
		r:add(new PieceType('pawn', [ '♙', '♟' ], 1, ~:(board, pos, isAttack {
			return isAttack;
		})));
		return r;
	});
};

qlass Board {
	Objeqt pieces;
	
	fq Board({
		this:pieces <~ {
			A <~ [ 1, 2, 3, 4, 5, 6, 7, 8 ],
			B <~ [ 1, 2, 3, 4, 5, 6, 7, 8 ],
			C <~ [ 1, 2, 3, 4, 5, 6, 7, 8 ],
			D <~ [ 1, 2, 3, 4, 5, 6, 7, 8 ],
			E <~ [ 1, 2, 3, 4, 5, 6, 7, 8 ],
			F <~ [ 1, 2, 3, 4, 5, 6, 7, 8 ],
			G <~ [ 1, 2, 3, 4, 5, 6, 7, 8 ],
			H <~ [ 1, 2, 3, 4, 5, 6, 7, 8 ]
		};
	});

	Piece fq get(x, y { 
		<: this:pieces:@x:@y; 
	});
};

qlass Game {
	Objeqt pieceTypes;
	Board board;
	Qollection pieces;
};

qlass Input {
	*~ from;
	*~ to;

	fq read({ 
		*~ v <~ @Qonsole:readLine();
		cout(v);
		this:from <~ [ v:0, v:1 ];
		this:to <~ [ v:3, v:4 ];
		<: this;
	});
};


@Chess:definePieceTypes();